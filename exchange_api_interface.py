#!/usr/bin/python3
import logging

import constants

liqui_pairs = ['knc_eth']
logger = logging.getLogger(constants.LOGGER_NAME)


class ExchangeApiInterface:

    def parse_trade_args(self, args):
        pass

    def parse_get_balance_args(self, args):
        pass

    def parse_withdraw_args(self, args):
        pass

    def parse_deposit_args(self, args):
        pass


#

class TradeParams:

    def __init__(self, api_key, src_token, dst_token, qty, rate, buy):
        self.api_key = api_key
        self.src_token = src_token
        self.dst_token = dst_token
        self.qty = qty
        self.rate = rate
        self.buy = buy

#


class TradeOutput:

    def __init__(self, error, error_msg, order_id):
        """
        :param error: True or False
        :param error_msg: String containing the error message
        :order_id: integer for the order ID
        """
        self.error = error
        self.error_msg = error_msg
        self.order_id = order_id

#


class CancelTradeParams:

    def __init__(self, api_key, order_id):
        self.api_key = api_key
        self.order_id = order_id

#


class CancelTradeOutput:

    def __init__(self, error, error_msg, order_id):
        """
       :param error: True or False
       :param error_msg: String containing the error message
       :order_id: integer for the order ID
       """
        self.error = error
        self.error_msg = error_msg
        self.order_id = order_id

#


class GetBalanceParams:

    def __init__(self, api_key):
        self.api_key = api_key

#


class GetBalanceOutput:

    def __init__(self, error, error_msg, balance):
        """
        :param error: True or False
        :param error_msg: String containing the error message
        :param balance: Dictionary with { token1: amount1, token2: amount2}
         where token1,token2 .token attribute of Token object from
         constants.py  and amount1, amount2 is round(float, 8)
        """
        self.error = error
        self.error_msg = error_msg
        self.balance = balance

#


class DepositParams:

    def __init__(self, api_key, token, qty):
        self.api_key = api_key
        self.token = token
        self.qty = qty

#


class WithdrawParams:

    def __init__(
            self,
            api_key,
            token,
            qty,
            dst_address,
            withdraw_on_blockchain):
        self.api_key = api_key
        self.token = token
        self.qty = qty
        self.dst_address = dst_address
        self.withdraw_on_blockchain = withdraw_on_blockchain


class WithdrawOutput:

    def __init__(self, error, error_msg, transaction_id, qty):
        """
        :param error: True or False
        :param error_msg: String containing the error message
        :param transaction_id: integer, a transaction ID for the withdrawal
        :param qty: round(float, 8) with the qty withdraws
        """
        self.error = error
        self.error_msg = error_msg
        self.transaction_id = transaction_id
        self.qty = qty

#


class GetOrderSingleParams:

    def __init__(self, api_key, order_id):
        self.api_key = api_key
        self.order_id = order_id

#


class GetOrderSingleOutput:

    def __init__(self, error, error_msg, pair, type, original_qty,
                 remaining_qty):
        """
        :param error: True or False
        :param error_msg: String containing the error message
        :param original_qty: round(float, 8) with the qty requested originally
         for execution
        :param remaining_qty: round(float, 8) with the qty remaining
         for execution (original - executed , can be same as original for now)
        :param pair: the "constants.ALL_PAIRS" formatted pair
        :param type: "buy" or "sell"
        """
        self.error = error
        self.error_msg = error_msg
        self.pair = pair
        self.original_qty = original_qty
        self.remaining_qty = remaining_qty
        self.type = type

#


class GetOrdersOpenParams:

    def __init__(self, api_key):
        self.api_key = api_key

#


class GetHistoryParams:

    def __init__(self, api_key):
        self.api_key = api_key

#


class LiquiApiInterface(ExchangeApiInterface):

    def __init__(self):
        pass

    @staticmethod
    def check_answers(exchange_results, required_results):
        """Checks the replies from the exchange for any errors.
         :param exchange_results: is a class object generated by the
         exchange"""
        answers = vars(exchange_results)
        if len(answers) > 10 or not (
                all(p in answers for p in required_results)):
            return False, "missing required results or too many results"
        for key, value in answers.items():
            if not isinstance(key, str):
                return False, "key type"
            if key == "error" and not isinstance(value, bool):
                return False, "error type"
            if key == "error_msg" and not isinstance(value, str):
                return False, "error message type"
            if key == "order_id":
                if not isinstance(value, int):
                    return False, "order_id type"
                if 0 > value:
                    return False, "order_id value"
            if key == "balance":
                if not isinstance(value, dict):
                    return False, "balance type"
                for k, v in value.items():
                    if not isinstance(v, float):
                        return False, "balance value type"
                    if v < 0:
                        return False, "balance value negative"
            if key == "transaction_id":
                if not isinstance(value, int):
                    return False, "transaction id type"
                if value < 0:
                    return False, "transaction id value"
            if key == "original_qty":
                if not isinstance(value, float):
                    return False, "original_quantity type"
                if value < 0:
                    return False, "original_quantity negative"
            if key == "remaining_qty":
                if not isinstance(value, float):
                    return False, "remaining_quantity type"
                if value < 0:
                    return False, "remaining_quantity negative"
                if value > answers["original_qty"]:
                    return False, "remaining_quantity > original_quantity"
            if key == "type":
                if not isinstance(value, str):
                    return False, "buy/sell type"
                if value.lower() not in ["buy", "sell"]:
                    return False, "buy/sell value"
        return True, True

    @staticmethod
    def parse_answers(exchange_results, required_results):
        """Converts the exchange results to liqui results
         :param exchange_results: is a class object generated by the
         exchange"""
        answers = vars(exchange_results)
        replies = {"return": {}}
        for key, value in answers.items():
            if key in required_results:
                if key == "error" and value:
                    replies["success"] = 0
                    replies["error"] = answers["error_msg"]
                    replies.pop("return")
                    return replies
                elif key == "error":
                    replies["success"] = 1
                if key == "order_id":
                    replies["return"]["order_id"] = value
                if key == "balance":
                    funds = {}
                    for k, v in value.items():
                        funds[str(k).lower()] = round(v, 8)
                    replies["return"]["funds"] = funds
                if key == "transaction_id":
                    replies["return"]["tId"] = value
                if key == "original_qty":
                    replies["return"]["received"] = round(value, 8)
                if key == "remaining_qty":
                    replies["return"]["remains"] = round(value, 8)
                if key == "type":
                    replies["return"]["type"] = value.lower()
        return replies

    @staticmethod
    def translate_args(post_args, parameters):
        cleaned_post_args = {}
        if len(post_args) > 10 or not (
                all(p in post_args for p in parameters)):
            raise ValueError("Invalid parameters in post request")
        for key, value in post_args.items():
            if key == "nonce":
                value = int(value)
                if value <= 0 or value > 4294967294:
                    raise ValueError("Invalid nonce: {}".format(value))
            if key == "type":
                if value == "sell":
                    cleaned_post_args.update(
                        {
                            "src_token": constants.KNC,
                            "dst_token": constants.ETH,
                            "buy": False
                        }
                    )
                elif value == "buy":
                    cleaned_post_args.update(
                        {
                            "src_token": constants.ETH,
                            "dst_token": constants.KNC,
                            "buy": True
                        }
                    )
            if key == "pair":
                if value not in liqui_pairs:
                    raise ValueError("Invalid pair: {}".format(value))
            if key == "coinname":
                if value not in constants.LIQUI_TOKENS:
                    raise ValueError("Invalid coinname: {}".format(value))
                cleaned_post_args["token"] = value.upper()
            if key == "address":
                cleaned_post_args["dst_address"] = int(value)
            if key == "api_key":
                cleaned_post_args["api_key"] = value.lower()
            if key == "rate":
                value = round(float(value), 8)
                if value <= 0 or value >= 1000000:
                    raise ValueError("Invalid rate: {}".format(value))
                cleaned_post_args["rate"] = value
            if key == "amount":
                value = round(float(value), 8)
                if value <= 0:
                    raise ValueError("Invalid amount: {}".format(value))
                cleaned_post_args["qty"] = round(value, 8)
            if key.lower() == "order_id":
                cleaned_post_args["order_id"] = int(value)
        return cleaned_post_args

    @staticmethod
    def parse_to_exchange(method, args):

        required_params = {
            "Trade": ["pair", "type", "rate", "amount", "api_key"],
            "getInfo": ["api_key"],
            "WithdrawCoin": ["coinname", "address", "amount", "api_key"]
            # "CancelOrder" : ["order_id", "api_key"],
            # "ActiveOrders": ["api_key"],
            # "TradeHistory": ["api_key"]
        }
        if method not in required_params:
            exchange_actions = {
                "success": 0, "error": "Invalid method requested"}
        else:
            logger.debug("Post args: %s", args)
            try:
                exchange_actions = LiquiApiInterface.translate_args(
                    args, required_params[method])
            except ValueError as e:
                logger.error(e)
                exchange_actions = {
                    "success": 0,
                    "error": "Invalid parameters in post request"}
            # if LiquiApiInterface.check_args(args,
            #                                 required_params[method]):
            #     exchange_actions = LiquiApiInterface.parse_args(
            #         args, required_params[method])
            # else:
            #     exchange_actions = {
            #         "success": 0,
            #         "error": "Invalid parameters in post request"}
        logger.info("Parsed params to exchange: %s", exchange_actions)
        return exchange_actions

    def parse_from_exchange(method, exchange_results):
        required_returns = {
            "Trade": ["order_id", "error", "error_msg"],
            "getInfo": ["balance", "error", "error_msg"],
            "WithdrawCoin": ["transaction_id", "error", "error_msg"]
            # "CancelOrder": ["order_id", "error", "error_msg"],
            # "OrderInfo": ["order_id", "error", "error_msg",
            #               "original_qty", "remaining_qty", "type"],
            # "ActiveOrders":,
            # "TradeHistory":,
        }

        check = LiquiApiInterface.check_answers(exchange_results,
                                                required_returns[method])
        if not check[0]:
            exchange_replies = {"success": 0, "error": check[1]}
        else:
            exchange_replies = LiquiApiInterface.parse_answers(
                exchange_results, required_returns[method])
        return exchange_replies
    parse_from_exchange = staticmethod(parse_from_exchange)


def all_to_exchange(pair, exchange):
    """common pair to exchange pair
    :param pair: any pair in format of exchanges as shown in constants.py
     EXCHANGENAME_PAIRS
    :param exchange:  any object of class Exchange  in constants.py
     """

    def finddash(commonpair):
        """Get the first part of the common pair"""
        position = commonpair.index("-")
        return commonpair[:position]

    if pair in constants.ALL_PAIRS:
        basecur = finddash(pair.upper())
        for i in exchange.pairs:
            if i.upper().startswith(basecur) or (
                    i.upper().endswith(basecur)):
                return i

        else:
            raise ValueError("Pair is not a common pair")


def exchange_to_all(pair, exchange):
    """ Exchange pair to common pair
    :param pair: any pair in format of exchanges as shown in constants.py
     EXCHANGENAME_PAIRS
    :param exchange:  any object of class Exchange  in constants.py
     """

    def find_bit(pair):
        """Get the base ccy of the common pair for Bittrex"""
        position = pair.index("-")
        return pair[position + 1:]

    def find_liq(pair):
        """Get the base ccy of the common pair for Liqui"""
        position = pair.index("_")
        return pair[:position]

    def find_bi(pair):
        """Get the base ccy of the common pair for binance or bitfinex"""
        pair = pair.lower()
        position = pair.index(constants.ETH.token)
        return pair[:position]
    if pair in exchange.pairs:
        if exchange == constants.BITTREX.exchange:
            basecur = find_bit(pair)
        elif exchange == constants.LIQUI.exchange:
            basecur = find_liq(pair)
        else:
            basecur = find_bi(pair)
        for i in constants.ALL_PAIRS:
            if i.startswith(basecur.upper()):
                return i.lower()
